import React, { useState, useCallback, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useApp } from "../../../../store/contexts/AppContext";
import { useAnswerPlayback } from "../../../../hooks/useAnswerPlayback";
import FillInQuestionCard from "../FillInQuestionCard";
import ExampleSentence from "../ExampleSentence";
import SettingsPanel from "../../../../components/SettingsPanel";
import Modal from "../../../../components/Modal";
import {
  AppContainer,
  Title,
  Progress,
  SettingsToggle,
  FloatingSettingsPanel,
  InfoToggle,
  Overlay,
  BackPage,
} from "../../../../components/App/styles";
import styled from "styled-components";
import {
  nextQuestionGame,
  restartQuiz,
  startQuiz,
  recordFillInResult,
} from "../../../../pages/quiz/reducer/actions";
import quizProgressService from "../../../../services/quizProgressService";
import readingProgressService from "../../../../services/readingProgressService";
import fillinProgressService from "../../../../services/fillinProgressService";
import StatisticsPage from "../StatisticsPage";
import AudioRecorderPage from "../../../AudioRecorder";
import {
  commitPendingProficiencyUpdates,
  updateWordInNotebook,
} from "../../../../store/reducer/actions";
import notebookService from "../../../../services/notebookService";
import { setCurrentNotebook } from "../../../../store/reducer/actions";
import { updatePendingProficiency } from "../../../../store/reducer/actions"; // Êñ∞Â¢ûÔºöÊõ¥Êñ∞ÁÜüÁ∑¥Â∫¶ÔºàpendingÔºâ
import {
  ProficiencyControlContainer as StatProficiencyControlContainer,
  ProficiencyButton as StatProficiencyButton,
} from "../StatisticsPage/styles"; // Êñ∞Â¢ûÔºöÊ≤øÁî®Áµ±Ë®àÈ†ÅÈù¢ÁöÑÁÜüÁ∑¥Â∫¶Ê®£ÂºèÔºàÈùûÁµïÂ∞çÂÆö‰ΩçÔºâ

const IconContainer = styled.div`
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 100;
`;
const IconGroup = styled.div`
  display: flex;
  gap: 10px;
  flex-direction: row-reverse;
`;
const HomeIcon = styled(SettingsToggle)`
  right: 5px;
`;

// Top bar: recorder (left) + controls (right)
const TopBar = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
`;

const RightPanel = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
`;

const TinyButton = styled.button`
  padding: 2px 6px;
  border: 1px solid #ccc;
  border-radius: 5px;
  background-color: #f0f0f0;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
  line-height: 1.4;

  &:hover {
    background-color: #e7e7e7;
  }

  &.active {
    background-color: #007bff;
    color: white;
    border-color: #007bff;
  }
`;

const proficiencyMap = { 1: "‰Ωé", 2: "‰∏≠", 3: "È´ò" };
const sortOrderMap = { random: "Èö®Ê©ü", aiueo: "„ÅÇ„ÅÑ„ÅÜ„Åà„Åä", none: "È†êË®≠" };

function Content() {
  const [showSettings, setShowSettings] = useState(false);
  const [showExitConfirmModal, setShowExitConfirmModal] = useState(false);
  const [showInfoModal, setShowInfoModal] = useState(false);
  const navigate = useNavigate();
  const [result, setResult] = useState(null); // '‚≠ï' | '‚ùå' | null
  const [selectedAnswer, setSelectedAnswer] = useState("");
  const [isBug, setIsBug] = useState(false);

  const { state, dispatch } = useApp();
  const { questions, currentQuestionIndex } = state.quiz;
  const {
    playbackOptions,
    playbackSpeed,
    autoProceed,
  gameSoundEffects,
    proficiencyFilter,
    startQuestionIndex,
    wordRangeCount,
    sortOrder,
    wordType,
  } = state.systemSettings;
  const { notebooks, currentNotebookId } = state.shared;
  const question = questions[currentQuestionIndex];

  const currentNotebook = notebooks.find((n) => n.id === currentNotebookId);
  const notebookName = currentNotebook ? currentNotebook.name : "";
  const selectedProficiencies = Object.entries(proficiencyFilter)
    .filter(([, value]) => value)
    .map(([key]) => proficiencyMap[key])
    .join(", ");

  const handleConfirmExit = useCallback(() => {
    try {
      quizProgressService.clearProgress();
      readingProgressService.clearProgress();
      fillinProgressService.clearProgress();
    } catch {}
    dispatch(commitPendingProficiencyUpdates());
    dispatch(restartQuiz());
    setShowExitConfirmModal(false);
    navigate("/");
    window.location.reload();
  }, [dispatch, navigate]);

  const handleCancelExit = useCallback(() => {
    setShowExitConfirmModal(false);
  }, []);

  // Use hook only for speaking/cancel; handle result playback and auto-next manually to avoid double triggers
  const { playSequence, cancelPlayback } = useAnswerPlayback({
    question,
    onNext: () => {},
    playbackOptions,
    rate: playbackSpeed,
  gameSoundEffects,
  });

  const speakManually = useCallback(
    (text, lang) => {
      const options = {};
      if (lang === "ja") {
        options.jp = true;
        playSequence(null, { jp_word: text }, options, { skipSound: true });
      } else if (lang === "zh") {
        options.ch = true;
        playSequence(null, { ch_word: text }, options, { skipSound: true });
      }
    },
    [playSequence]
  );

  // È°åÁõÆÂàáÊèõÊôÇËá™ÂãïÊí≠ÊîæÁôºÈü≥ÔºàËàá Quiz ‰∏ÄËá¥Ôºâ
  useEffect(() => {
    if (question && question.jp_word) {
      speakManually(question.jp_word, "ja");
    }
  }, [question, speakManually]);

  useEffect(() => {
    setIsBug(question ? !!question.word_bug : false);
  }, [question?.id, question?.word_bug]);

  // Ê∏ÖÁêÜÁãÄÊÖãÊñºÈ°åÁõÆÂàáÊèõ
  useEffect(() => {
    setResult(null);
    setSelectedAnswer("");
  }, [currentQuestionIndex]);

  // Âú®ÁµêÊûúÈ†ÅÊí≠ÊîæÁ≠îÈ°åÈü≥ËàáË™ûÈü≥ÔºåÁµêÊùüÂæå‰æùË®≠ÂÆöËá™ÂãïÂâçÈÄ≤
  useEffect(() => {
    if (!result || !question) return;
    let stopped = false;
    (async () => {
      await playSequence(result, question, playbackOptions, {
        skipSound: !gameSoundEffects,
      });
      if (stopped) return;
      if (autoProceed) {
        // Clear local result beforeË∑≥‰∏ã‰∏ÄÈ°åÔºåÈÅøÂÖçÂú® question ÊîπËÆä‰ΩÜ result ‰ªçÁÇ∫ÁúüÊôÇÂÜçÊ¨°Ëß∏ÁôºÊ≠§ÊïàÊûúËÄåÈáçÊí≠Á≠îÈ°åÈü≥
        setResult(null);
        setSelectedAnswer("");
        dispatch(nextQuestionGame());
      }
    })();
    return () => {
      stopped = true;
      cancelPlayback();
    };
  }, [
    result,
    question,
    playbackOptions,
    autoProceed,
    dispatch,
    playSequence,
    cancelPlayback,
    gameSoundEffects,
  ]);

  // Ëá™ÂãïÂÑ≤Â≠ò Fill-in ÈÄ≤Â∫¶ÔºàÁßªÂãïÂà∞‰∏ã‰∏ÄÈ°åÊôÇÔºâ
  const prevIndexRef = React.useRef(state.quiz.currentQuestionIndex);
  useEffect(() => {
    const idx = state.quiz.currentQuestionIndex;
    const prev = prevIndexRef.current;
    prevIndexRef.current = idx;
    if (state.quiz.quizCompleted) return;
    if (idx > prev && state.quiz.questions.length > 0) {
      const questionIds = state.quiz.questions.map((q) => q.id);
      const results = state.quiz.answeredQuestions.map((a) => a.isCorrect);
      fillinProgressService.saveProgress({
        notebookId: state.shared.currentNotebookId,
        questionIds,
        currentIndex: idx,
        results,
        sortOrder,
      });
    }
  }, [
    state.quiz.currentQuestionIndex,
    state.quiz.questions,
    state.quiz.answeredQuestions,
    state.quiz.quizCompleted,
    sortOrder,
    state.shared.currentNotebookId,
  ]);

  // ‰æùË®≠ÂÆöÂëàÁèæÊó•ÊñáÈ°ØÁ§∫ÔºàÂÅáÂêç/Êº¢Â≠ó/Êº¢Â≠ó+rubyÔºâ
  const renderWordByType = useCallback(() => {
    if (!question) return null;
    if (wordType === "kanji_jp_word") {
      return <span>{question.kanji_jp_word || question.jp_word}</span>;
    }
    if (wordType === "jp_word") {
      return <span>{question.jp_word}</span>;
    }
    if (wordType === "jp_context" && Array.isArray(question.jp_context)) {
      return (
        <span>
          {question.jp_context.map((part, index) =>
            part.kanji ? (
              <ruby key={index}>
                {part.kanji}
                <rt>{part.hiragana}</rt>
              </ruby>
            ) : (
              <span key={index}>{part.hiragana}</span>
            )
          )}
        </span>
      );
    }
    // fallback
    return <span>{question.jp_word}</span>;
  }, [question, wordType]);

  return (
    <AppContainer>
      <IconContainer>
        <IconGroup>
          <SettingsToggle onClick={() => setShowSettings((s) => !s)}>
            ‚öôÔ∏è
          </SettingsToggle>
          <HomeIcon onClick={() => setShowExitConfirmModal(true)}>‚Ü©Ô∏è</HomeIcon>
          <InfoToggle onClick={() => setShowInfoModal(true)}>‚ÑπÔ∏è</InfoToggle>
          <BackPage onClick={() => navigate("/")}>üè†</BackPage>
        </IconGroup>
      </IconContainer>

      {showSettings && (
        <>
          <Overlay onClick={() => setShowSettings(false)} />
          <FloatingSettingsPanel>
            <SettingsPanel context="fillin" />
          </FloatingSettingsPanel>
        </>
      )}

      <Title>ÊãºÂ≠óÁ∑¥Áøí</Title>
      <Progress>
        Á¨¨ {currentQuestionIndex + 1} È°å / ÂÖ± {questions.length} È°å
      </Progress>

      {/* Top bar: left recorder, right proficiency/bug panel */}
      <TopBar>
        <div style={{ display: "flex", justifyContent: "flex-start" }}>
          <AudioRecorderPage triggerReset={currentQuestionIndex} />
        </div>
        {question && (
          <RightPanel>
            <TinyButton
              className={
                (state.shared.pendingProficiencyUpdates[question.id] ||
                  question.proficiency) === 1
                  ? "active"
                  : ""
              }
              onClick={() => dispatch(updatePendingProficiency(question.id, 1))}
              title="Ë®≠ÁÇ∫‰ΩéÁÜüÁ∑¥Â∫¶"
            >
              ‰Ωé
            </TinyButton>
            <TinyButton
              className={
                (state.shared.pendingProficiencyUpdates[question.id] ||
                  question.proficiency) === 2
                  ? "active"
                  : ""
              }
              onClick={() => dispatch(updatePendingProficiency(question.id, 2))}
              title="Ë®≠ÁÇ∫‰∏≠ÁÜüÁ∑¥Â∫¶"
            >
              ‰∏≠
            </TinyButton>
            <TinyButton
              className={
                (state.shared.pendingProficiencyUpdates[question.id] ||
                  question.proficiency) === 3
                  ? "active"
                  : ""
              }
              onClick={() => dispatch(updatePendingProficiency(question.id, 3))}
              title="Ë®≠ÁÇ∫È´òÁÜüÁ∑¥Â∫¶"
            >
              È´ò
            </TinyButton>
            <TinyButton
              className={isBug ? "active" : ""}
              onClick={async () => {
                try {
                  const newVal = !isBug;
                  setIsBug(newVal);
                  await notebookService.updateWordInNotebook(
                    state.shared.currentNotebookId,
                    question.id,
                    { word_bug: newVal }
                  );
                  dispatch(
                    updateWordInNotebook(
                      state.shared.currentNotebookId,
                      question.id,
                      { word_bug: newVal }
                    )
                  );
                } catch (e) {
                  console.error("toggle bug (FillIn top bar) failed", e);
                  setIsBug((prev) => !prev);
                }
              }}
              title="Ê®ôË®òÁÇ∫ÈåØË™§/ÂèñÊ∂à"
            >
              ÈåØ
            </TinyButton>
          </RightPanel>
        )}
      </TopBar>

      {!result && (
        <FillInQuestionCard
          question={question}
          allQuestions={questions}
          onComplete={({ correct, guess }) => {
            setSelectedAnswer(guess);
            setResult(correct ? "‚≠ï" : "‚ùå");
            // Á¥ÄÈåÑÂ°´Á©∫‰ΩúÁ≠îÁµêÊûúÔºåËÆìÁµêÁÆóÈ†ÅËàáÈÄ≤Â∫¶ÂÑ≤Â≠òÊ≠£Á¢∫
            dispatch(recordFillInResult(correct));
          }}
          speak={(text, lang) => speakManually(text, lang)}
        />
      )}

      {result && (
        <div style={{ maxWidth: 720, margin: "0 auto", padding: 12 }}>
          {/* ÁÜüÁ∑¥Â∫¶/ÈåØË™§ÊéßÂà∂Â∑≤ÁßªËá≥È†ÇÈÉ®Âè≥ÂÅ¥Èù¢Êùø */}

          <div
            style={{
              borderRadius: 12,
              border: `1px solid ${result === "‚≠ï" ? "#4caf50" : "#e53935"}`,
              padding: 12,
              background: result === "‚≠ï" ? "#e8f5e9" : "#ffebee",
              marginBottom: 12,
            }}
          >
            <div style={{ fontSize: 18, marginBottom: 6 }}>
              {question.ch_word} [{question.type}]
            </div>
            <div style={{ fontSize: 18 }}>
              {selectedAnswer} {result}
            </div>
            {/* ‰æùË®≠ÂÆöÈ°ØÁ§∫Êó•ÊñáÁ≠îÊ°à */}
            <div style={{ fontSize: 18, marginTop: 8 }}>
              Êó•ÊñáÔºö{renderWordByType()}{" "}
              <button
                style={{ marginLeft: 8 }}
                onClick={() => speakManually(question.jp_word, "ja")}
                aria-label="Êí≠ÊîæÊó•ÊñáÁôºÈü≥"
              >
                üîä
              </button>
            </div>
          </div>
          <ExampleSentence
            jp_ex={question.jp_ex_statement}
            ch_ex={question.ch_ex_statement}
            speak={speakManually}
            jp_ex_context={question.jp_ex_statement_context}
          />
          <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
            <button
              onClick={() => {
                cancelPlayback();
                setResult(null);
                setSelectedAnswer("");
                dispatch(nextQuestionGame());
              }}
            >
              ‰∏ã‰∏ÄÈ°å
            </button>
            {autoProceed && (
              <span
                style={{ fontSize: 12, color: "#666", alignSelf: "center" }}
              >
                Ëá™ÂãïÂâçÈÄ≤Â∑≤ÈñãÂïü
              </span>
            )}
          </div>
        </div>
      )}

      <Modal
        message="Ë¶ÅÁµÇÊ≠¢Ê∏¨È©óÔºå‰∏¶ÂÑ≤Â≠òÁÜüÁ∑¥Ê®ôÁ±§Èõ¢ÈñãÂóéÔºü"
        onConfirm={handleConfirmExit}
        onCancel={handleCancelExit}
        isVisible={showExitConfirmModal}
      />

      <Modal
        message={
          <div style={{ textAlign: "left" }}>
            <p>Á≠ÜË®òÊú¨ÂêçÁ®±: {notebookName}</p>
            <p>ÁÜüÁ∑¥Â∫¶: {selectedProficiencies}</p>
            <p>ÊéíÂ∫è: {sortOrderMap[sortOrder]}</p>
            <p>ÂñÆÂ≠óËµ∑ÂßãÁ¥¢Âºï: {startQuestionIndex}</p>
            <p>ÂñÆÂ≠óÁØÑÂúç: {wordRangeCount}</p>
          </div>
        }
        onConfirm={() => setShowInfoModal(false)}
        disableCancel
        isVisible={showInfoModal}
      />
    </AppContainer>
  );
}

export default function FillInQuiz() {
  const { state, dispatch } = useApp();
  const { notebooks, currentNotebookId } = state.shared;
  const {
    proficiencyFilter,
    startQuestionIndex,
    wordRangeCount,
    sortOrder,
    playbackOptions,
    playbackSpeed,
    wordType,
  } = state.systemSettings;
  const { quizCompleted, answeredQuestions, correctAnswersCount } = state.quiz;
  const [emptyAlert, setEmptyAlert] = useState(false);
  const [hydratedFromProgress, setHydratedFromProgress] = useState(false);
  const navigate = useNavigate();

  const { playSequence } = useAnswerPlayback({
    onNext: () => dispatch(nextQuestionGame()),
    playbackOptions,
    rate: playbackSpeed,
  });

  const speakManually = useCallback(
    (text, lang) => {
      const options = {};
      if (lang === "ja") {
        options.jp = true;
        playSequence(null, { jp_word: text }, options, { skipSound: true });
      } else if (lang === "zh") {
        options.ch = true;
        playSequence(null, { ch_word: text }, options, { skipSound: true });
      }
    },
    [playSequence]
  );

  // ÂòóË©¶ÂæûÊú¨Âú∞ÈÄ≤Â∫¶ÈÇÑÂéüÔºàFill-in Â∞àÁî®Ôºâ
  useEffect(() => {
    if (quizCompleted) return;
    const saved = fillinProgressService.loadProgress();
    if (!saved) return;
    if (!notebooks || notebooks.length === 0) return;

    const {
      notebookId: savedNotebookId,
      questionIds,
      currentIndex,
      results,
    } = saved;

    if (savedNotebookId && savedNotebookId !== currentNotebookId) {
      dispatch(setCurrentNotebook(savedNotebookId));
      notebookService.setCurrentNotebookId(savedNotebookId);
    }

    const nb = notebooks.find((n) => n.id === savedNotebookId);
    if (!nb) return;

    const byId = new Map((nb.context || []).map((w) => [w.id, w]));
    const restoredQuestions = (questionIds || [])
      .map((id) => byId.get(id))
      .filter(Boolean);

    if (restoredQuestions.length === 0) return;

    const clampedIndex = Math.min(
      Math.max(0, currentIndex || 0),
      restoredQuestions.length
    );
    const trimmedResults = Array.isArray(results)
      ? results.slice(0, clampedIndex)
      : [];

    dispatch({
      type: "quiz/LOAD_PROGRESS",
      payload: {
        questions: restoredQuestions,
        currentIndex: clampedIndex,
        results: trimmedResults,
      },
    });
    setHydratedFromProgress(true);
  }, [quizCompleted, notebooks, currentNotebookId, dispatch]);

  // Ê≠£Â∏∏ÂàùÂßãÂåñÔºàËã•Ê≤íÊúâÊú¨Âú∞ÈÄ≤Â∫¶Êàñ‰∏çÂêåÁ≠ÜË®òÊú¨Ôºâ
  useEffect(() => {
    if (!quizCompleted && !hydratedFromProgress) {
      // ÈÅøÂÖçÂú®È°åÁõÆÂ∑≤ËºâÂÖ•ÁöÑÊÉÖÊ≥Å‰∏ãÔºåÂõ† notebooks ÂÖßÂÆπÊõ¥Êñ∞Ôºà‰æãÂ¶Ç word_bug ÂàáÊèõÔºâËÄåÈáçÊñ∞ÂàùÂßãÂåñ‰∏¶ÊîπËÆäÈ†ÜÂ∫è
      if (state.quiz.questions && state.quiz.questions.length > 0) return;
      const saved = fillinProgressService.loadProgress();
      if (
        saved &&
        notebooks &&
        notebooks.some((n) => n.id === saved.notebookId)
      )
        return;
      const currentNotebook = notebooks.find((n) => n.id === currentNotebookId);
      if (currentNotebook) {
        let questions = currentNotebook.context.filter((q) => {
          if (!q.jp_word) return false;
          return proficiencyFilter[q.proficiency];
        });
        const startIndex = Math.max(0, startQuestionIndex - 1);
        const endIndex = Math.min(
          questions.length,
          startIndex + wordRangeCount
        );
        questions = questions.slice(startIndex, endIndex);
        if (questions.length > 0) {
          dispatch(startQuiz(questions, sortOrder));
        } else {
          setEmptyAlert(true);
        }
      }
    }
  }, [
    currentNotebookId,
    dispatch,
    quizCompleted,
    hydratedFromProgress,
    proficiencyFilter,
    notebooks,
    startQuestionIndex,
    wordRangeCount,
    sortOrder,
  ]);

  // ÂÆåÊàêÂæå‰ΩøÁî®Âêå‰∏ÄÂÄãÁµ±Ë®àÈ†Å
  if (quizCompleted) {
    return (
      <StatisticsPage
        answeredQuestions={answeredQuestions}
        correctAnswersCount={correctAnswersCount}
        speakManually={speakManually}
        wordType={wordType}
      />
    );
  }

  if (state.quiz.questions.length === 0) {
    return (
      <>
        <Modal
          message="Ë´ãË™øÊï¥ÂñÆÂ≠óÁØÑÂúçÊàñÁ≠ÜË®òÊú¨!"
          onConfirm={() => {
            navigate("/settings");
          }}
          disableCancel
          isVisible={emptyAlert}
        />
        <div>Loading questions...</div>
      </>
    );
  }

  return <Content />;
}
